<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on dProc Articles</title><link>/</link><description>Recent content in Introduction on dProc Articles</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 28 Sep 2014 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>Interfaces</title><link>/docs/interfaces/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/interfaces/</guid><description>Interfaces and structs dProc is a very small package and as such there are very few interfaces. The package is fairly opinionated but the interfaces allows for custom processes if the need arises.
For the high-level overview, there are 4 main interfaces or types: Message, Process, Handler and the Engine. Messages are used to pass data through the pipeline, processes handle the pipeline life-cycle, handlers handle the messages and the engine manages all the processes.</description></item><item><title>Intro</title><link>/docs/intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/intro/</guid><description>Welcome to the dProc docs! So you read the homepage and clicked this link. Now you&amp;rsquo;re probably asking yourself what the hell is dProc and why do I need it? So without further ado&amp;hellip;
What is dProc? dProc is a small, generic data processing library written in Go. It is modeled after Actors and a bit of Flow-based programming. It is a small library (&amp;lt; 250 lines of code) with very few interfaces.</description></item><item><title>Engine</title><link>/docs/engine/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/engine/</guid><description>Engine The dproc.Engine is similar to a pipeline. It allows for many processes to be created and organized before the entire pipeline is executed. The Engine can be managed with a context.Context, context.CancelFunc and a sync.WaitGroup allowing for the pipeline to be killed.
Here&amp;rsquo;s the interface:
// Engine manages the pipeline type Engine interface { Start(*sync.WaitGroup) Stop() } Starting the engine Starting the Engine is simple. It requires calling engine.</description></item><item><title>Handlers</title><link>/docs/handlers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/handlers/</guid><description>Handlers Handlers handle incoming messages as well as send messages to child processes. The interface only has one method.
type Handler interface { Handle(ctx context.Context, proc Process, msg Message) } The Engine context.Context is passed in mainly for long running processes. However, ctx.Done() is monitored between function calls regardless. The Process is included as the Handler can modify the process State and is needed to dispatch messages.
Implementing Handlers Implementing handlers is a relatively straightforward task.</description></item><item><title>Messages</title><link>/docs/messages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/messages/</guid><description>Messages Messages are the primary mechanism for communicating with other processes. The struct looks like this:
type Message struct { Timestamp time.Time Type MessageType Forward bool Value interface{} } Message fields
Timestamp: When the message was created (e.g. time.Now().UTC()) Type: MessageType is just a string type for quick type-switching when processing the message Forward: If true, the message will be sent to all child nodes recursively. Otherwise, it will only be sent to the process&amp;rsquo; direct children and no further.</description></item><item><title>Processes</title><link>/docs/processes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/processes/</guid><description>Processes Processes wrap a handler with a life-cycle and dispatch messages to the handler. Each processes runs in a separate go-routine to maximize concurrency. Each process has a unique ID, an internal State, an inbox and a Handler.
// Process processes incoming messages and sends messages to other Processes. type Process interface { // Name is used primarily for logging purposes Name() string // SetState can be used to update the Process&#39; internal state outside of the normal lifecycle.</description></item><item><title>Random</title><link>/docs/examples/random/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/examples/random/</guid><description/></item><item><title>Creating a New Theme</title><link>/posts/creating-a-new-theme/</link><pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate><guid>/posts/creating-a-new-theme/</guid><description>Introduction This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&amp;rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&amp;rsquo;t cover using CSS to style your theme.
We&amp;rsquo;ll start with creating a new site with a very basic template.</description></item><item><title>Migrate to Hugo from Jekyll</title><link>/posts/migrate-from-jekyll/</link><pubDate>Mon, 10 Mar 2014 00:00:00 +0000</pubDate><guid>/posts/migrate-from-jekyll/</guid><description>Move static content to static Jekyll has a rule that any directory not starting with _ will be copied as-is to the _site output. Hugo keeps all static content under static. You should therefore move it all there. With Jekyll, something that looked like
▾ &amp;lt;root&amp;gt;/ ▾ images/ logo.png should become
▾ &amp;lt;root&amp;gt;/ ▾ static/ ▾ images/ logo.png Additionally, you&amp;rsquo;ll want any files that should reside at the root (such as CNAME) to be moved to static.</description></item><item><title>(Hu)go Template Primer</title><link>/posts/goisforlovers/</link><pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate><guid>/posts/goisforlovers/</guid><description>Hugo uses the excellent Go html/template library for its template engine. It is an extremely lightweight engine that provides a very small amount of logic. In our experience that it is just the right amount of logic to be able to create a good static website. If you have used other template systems from different languages or frameworks you will find a lot of similarities in Go templates.
This document is a brief primer on using Go templates.</description></item><item><title>Getting Started with Hugo</title><link>/posts/hugoisforlovers/</link><pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate><guid>/posts/hugoisforlovers/</guid><description>Step 1. Install Hugo Go to Hugo releases and download the appropriate version for your OS and architecture.
Save it somewhere specific as we will be using it in the next step.
More complete instructions are available at Install Hugo
Step 2. Build the Docs Hugo has its own example site which happens to also be the documentation site you are reading right now.
Follow the following steps:
Clone the Hugo repository Go into the repo Run hugo in server mode and build the docs Open your browser to http://localhost:1313 Corresponding pseudo commands:</description></item></channel></rss>