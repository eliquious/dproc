<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docs on dProc Articles</title><link>/docs/</link><description>Recent content in Docs on dProc Articles</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>Interfaces</title><link>/docs/interfaces/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/interfaces/</guid><description>Interfaces and structs dProc is a very small package and as such there are very few interfaces. The package is fairly opinionated but the interfaces allows for custom processes if the need arises.
For the high-level overview, there are 4 main interfaces or types: Message, Process, Handler and the Engine. Messages are used to pass data through the pipeline, processes handle the pipeline life-cycle, handlers handle the messages and the engine manages all the processes.</description></item><item><title>Intro</title><link>/docs/intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/intro/</guid><description>Welcome to the dProc docs! So you read the homepage and clicked this link. Now you&amp;rsquo;re probably asking yourself what the hell is dProc and why do I need it? So without further ado&amp;hellip;
What is dProc? dProc is a small, generic data processing library written in Go. It is modeled after Actors and a bit of Flow-based programming. It is a small library (&amp;lt; 250 lines of code) with very few interfaces.</description></item><item><title>Engine</title><link>/docs/engine/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/engine/</guid><description> Engine Starting the engine</description></item><item><title>Handlers</title><link>/docs/handlers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/handlers/</guid><description>Handlers Handlers handle incoming messages as well as send messages to child processes. The interface only has one method.
type Handler interface { Handle(ctx context.Context, proc Process, msg Message) } The Engine context.Context is passed in mainly for long running processes. However, ctx.Done() is monitored between function calls regardless. The Process is included as the Handler can modify the process State and is needed to dispatch messages.
Implementing Handlers Implementing handlers is a relatively straightforward task.</description></item><item><title>Messages</title><link>/docs/messages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/messages/</guid><description>Messages Messages are the primary mechanism for communicating with other processes. The struct looks like this:
type Message struct { Timestamp time.Time Type MessageType Forward bool Value interface{} } Message fields
Timestamp: When the message was created (e.g. time.Now().UTC()) Type: MessageType is just a string type for quick type-switching when processing the message Forward: If true, the message will be sent to all child nodes recursively. Otherwise, it will only be sent to the process&amp;rsquo; direct children and no further.</description></item><item><title>Processes</title><link>/docs/processes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/processes/</guid><description>Processes Processes wrap a handler with a life-cycle and dispatch messages to the handler. Each processes runs in a separate go-routine to maximize concurrency. Each process has a unique ID, an internal State, an inbox and a Handler.
// Process processes incoming messages and sends messages to other Processes. type Process interface { // Name is used primarily for logging purposes Name() string // SetState can be used to update the Process&#39; internal state outside of the normal lifecycle.</description></item><item><title>Random</title><link>/docs/examples/random/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/examples/random/</guid><description/></item></channel></rss>